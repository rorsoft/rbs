class Monitor
  public

  def enter: () -> nil

  def exit: () -> nil

  def mon_check_owner: () -> nil

  alias mon_enter enter

  alias mon_exit exit

  def mon_locked?: () -> bool

  def mon_owned?: () -> bool

  alias mon_synchronize synchronize

  alias mon_try_enter try_enter

  def new_cond: () -> ::MonitorMixin::ConditionVariable

  def synchronize: [T] () { () -> T } -> T

  def try_enter: () -> bool

  alias try_mon_enter try_enter

  def wait_for_cond: (::MonitorMixin::ConditionVariable, Numeric? timeout) -> untyped
end

module MonitorMixin
  def self.extend_object: (untyped obj) -> untyped

  public

  def mon_enter: () -> nil

  def mon_exit: () -> nil

  def mon_locked?: () -> bool

  def mon_owned?: () -> bool

  def mon_synchronize: [T] () { () -> T } -> T

  def mon_try_enter: () -> bool

  def new_cond: () -> ::MonitorMixin::ConditionVariable

  alias synchronize mon_synchronize

  alias try_mon_enter mon_try_enter

  private

  def initialize: (*untyped) { (*untyped) -> untyped } -> void

  def mon_check_owner: () -> nil

  def mon_initialize: () -> untyped
end

class MonitorMixin::ConditionVariable
  public

  def broadcast: () -> Thread::ConditionVariable

  def signal: () -> Thread::ConditionVariable

  def wait: (?Numeric? timeout) -> untyped

  def wait_until: () { () -> boolish } -> untyped

  def wait_while: () { () -> boolish } -> untyped

  private

  def initialize: (Monitor monitor) -> void
end
