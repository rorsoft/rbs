# A complex number can be represented as a paired real number with
# imaginary unit; a+bi. Where a is real part, b is imaginary part and i is
# imaginary unit. Real a equals complex a+0i mathematically.
# 
# [Complex](Complex) object can be created as literal,
# and also by using Kernel\#Complex,
# [::rect](Complex#method-c-rect),
# [::polar](Complex#method-c-polar) or
# [\#to\_c](Complex#method-i-to_c) method.
# 
#     2+1i                 #=> (2+1i)
#     Complex(1)           #=> (1+0i)
#     Complex(2, 3)        #=> (2+3i)
#     Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
#     3.to_c               #=> (3+0i)
# 
# You can also create complex object from floating-point numbers or
# strings.
# 
# ```ruby
# Complex(0.3)         #=> (0.3+0i)
# Complex('0.3-0.5i')  #=> (0.3-0.5i)
# Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)
# Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)
# 
# 0.3.to_c             #=> (0.3+0i)
# '0.3-0.5i'.to_c      #=> (0.3-0.5i)
# '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)
# '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)
# ```
# 
# A complex object is either an exact or an inexact number.
# 
# ```ruby
# Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)
# Complex(1, 1) / 2.0  #=> (0.5+0.5i)
# ```
class Complex < Numeric
  def self.polar: (*untyped) -> untyped

  def self.rect: (*untyped) -> untyped

  def self.rectangular: (*untyped) -> untyped

  public

  def *: (Integer arg0) -> Complex
       | (Float arg0) -> Complex
       | (Rational arg0) -> Complex
       | (BigDecimal arg0) -> Complex
       | (Complex arg0) -> Complex

  def **: (Integer arg0) -> Complex
        | (Float arg0) -> Complex
        | (Rational arg0) -> Complex
        | (BigDecimal arg0) -> Complex
        | (Complex arg0) -> Complex

  def +: (Integer arg0) -> Complex
       | (Float arg0) -> Complex
       | (Rational arg0) -> Complex
       | (BigDecimal arg0) -> Complex
       | (Complex arg0) -> Complex

  def +@: () -> Complex

  def -: (Integer arg0) -> Complex
       | (Float arg0) -> Complex
       | (Rational arg0) -> Complex
       | (BigDecimal arg0) -> Complex
       | (Complex arg0) -> Complex

  def -@: () -> Complex

  def /: (Integer arg0) -> Complex
       | (Float arg0) -> Complex
       | (Rational arg0) -> Complex
       | (BigDecimal arg0) -> Complex
       | (Complex arg0) -> Complex

  # Returns zero if `number` equals `other`, otherwise returns `nil`.
  #
  def <=>: (Numeric arg0) -> Integer

  def ==: (Object arg0) -> bool

  # Returns the absolute part of its polar form.
  #
  # ```ruby
  # Complex(-1).abs         #=> 1
  # Complex(3.0, -4.0).abs  #=> 5.0
  # ```
  def abs: () -> Numeric

  # Returns square of the absolute value.
  #
  # ```ruby
  # Complex(-1).abs2         #=> 1
  # Complex(3.0, -4.0).abs2  #=> 25.0
  # ```
  def abs2: () -> Numeric

  # Returns the angle part of its polar form.
  #
  # ```ruby
  # Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  # ```
  def angle: () -> Float

  # Returns the angle part of its polar form.
  #
  # ```ruby
  # Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  # ```
  def arg: () -> Float

  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. `clone` copies the frozen (unless :freeze
  # keyword argument is given with a false value) and tainted state of *obj*. See
  # also the discussion under `Object#dup`.
  #
  #     class Klass
  #        attr_accessor :str
  #     end
  #     s1 = Klass.new      #=> #<Klass:0x401b3a38>
  #     s1.str = "Hello"    #=> "Hello"
  #     s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
  #     s2.str[1,4] = "i"   #=> "i"
  #     s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
  #     s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  def clone: (?freeze: bool) -> self

  def coerce: (Numeric arg0) -> [ Complex, Complex ]

  # Returns the complex conjugate.
  #
  # ```ruby
  # Complex(1, 2).conjugate  #=> (1-2i)
  # ```
  def conj: () -> Complex

  # Returns the complex conjugate.
  #
  # ```ruby
  # Complex(1, 2).conjugate  #=> (1-2i)
  # ```
  def conjugate: () -> Complex

  # Returns the denominator (lcm of both denominator - real and imag).
  #
  # See numerator.
  def denominator: () -> Integer

  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. `dup` copies the tainted state of *obj*.
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  # ### on dup vs clone
  #
  # In general, `clone` and `dup` may have different semantics in descendant
  # classes. While `clone` is used to duplicate an object, including its internal
  # state, `dup` typically uses the class of the descendant object to create the
  # new instance.
  #
  # When using #dup, any modules that the object has been extended with will not
  # be copied.
  #
  #     class Klass
  #       attr_accessor :str
  #     end
  #
  #     module Foo
  #       def foo; 'foo'; end
  #     end
  #
  #     s1 = Klass.new #=> #<Klass:0x401b3a38>
  #     s1.extend(Foo) #=> #<Klass:0x401b3a38>
  #     s1.foo #=> "foo"
  #
  #     s2 = s1.clone #=> #<Klass:0x401b3a38>
  #     s2.foo #=> "foo"
  #
  #     s3 = s1.dup #=> #<Klass:0x401b3a38>
  #     s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401b3a38>
  #
  def dup: () -> self

  def eql?: (Object arg0) -> bool

  def fdiv: (Numeric arg0) -> Complex

  # Returns `true` if `num` is a finite number, otherwise returns `false`.
  #
  def finite?: () -> bool

  def hash: () -> Integer

  # Returns the imaginary part.
  #
  # ```ruby
  # Complex(7).imaginary      #=> 0
  # Complex(9, -4).imaginary  #=> -4
  # ```
  def imag: () -> (Integer | Float | Rational | BigDecimal)

  # Returns the imaginary part.
  #
  # ```ruby
  # Complex(7).imaginary      #=> 0
  # Complex(9, -4).imaginary  #=> -4
  # ```
  def imaginary: () -> (Integer | Float | Rational | BigDecimal)

  # Returns `nil`, -1, or 1 depending on whether the value is finite, `-Infinity`,
  # or `+Infinity`.
  #
  def infinite?: () -> Integer?

  # Returns the value as a string for inspection.
  #
  # ```ruby
  # Complex(2).inspect                       #=> "(2+0i)"
  # Complex('-8/6').inspect                  #=> "((-4/3)+0i)"
  # Complex('1/2i').inspect                  #=> "(0+(1/2)*i)"
  # Complex(0, Float::INFINITY).inspect      #=> "(0+Infinity*i)"
  # Complex(Float::NAN, Float::NAN).inspect  #=> "(NaN+NaN*i)"
  # ```
  def inspect: () -> String

  # Returns `true` if `num` is an Integer.
  #
  #     1.0.integer?   #=> false
  #     1.integer?     #=> true
  #
  def integer?: () -> bool

  # Returns the absolute part of its polar form.
  #
  # ```ruby
  # Complex(-1).abs         #=> 1
  # Complex(3.0, -4.0).abs  #=> 5.0
  # ```
  def magnitude: () -> (Integer | Float | Rational | BigDecimal)

  # Returns `self` if `num` is not zero, `nil` otherwise.
  #
  # This behavior is useful when chaining comparisons:
  #
  #     a = %w( z Bb bB bb BB a aA Aa AA A )
  #     b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
  #     b   #=> ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
  #
  def nonzero?: () -> self?

  # Returns the numerator.
  #
  # ```
  #     1   2       3+4i  <-  numerator
  #     - + -i  ->  ----
  #     2   3        6    <-  denominator
  #
  # c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)
  # n = c.numerator          #=> (3+4i)
  # d = c.denominator        #=> 6
  # n / d                    #=> ((1/2)+(2/3)*i)
  # Complex(Rational(n.real, d), Rational(n.imag, d))
  #                          #=> ((1/2)+(2/3)*i)
  # ```
  #
  # See denominator.
  def numerator: () -> Complex

  # Returns the angle part of its polar form.
  #
  # ```ruby
  # Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966
  # ```
  def phase: () -> Float

  # Returns an array; \[cmp.abs, cmp.arg\].
  #
  # ```ruby
  # Complex(1, 2).polar  #=> [2.23606797749979, 1.1071487177940904]
  # ```
  def polar: () -> [ Integer | Float | Rational | BigDecimal, Integer | Float | Rational | BigDecimal ]

  def quo: (Integer arg0) -> Complex
         | (Float arg0) -> Complex
         | (Rational arg0) -> Complex
         | (BigDecimal arg0) -> BigDecimal
         | (Complex arg0) -> Complex

  # Returns the value as a rational if possible (the imaginary part should
  # be exactly zero).
  #
  # ```ruby
  # Complex(1.0/3, 0).rationalize  #=> (1/3)
  # Complex(1, 0.0).rationalize    # RangeError
  # Complex(1, 2).rationalize      # RangeError
  # ```
  #
  # See to\_r.
  def rationalize: () -> Rational
                 | (?Numeric arg0) -> Rational

  # Returns the real part.
  #
  # ```ruby
  # Complex(7).real      #=> 7
  # Complex(9, -4).real  #=> 9
  # ```
  def real: () -> (Integer | Float | Rational | BigDecimal)

  # Returns false.
  def real?: () -> FalseClass

  # Returns an array; \[cmp.real, cmp.imag\].
  #
  # ```ruby
  # Complex(1, 2).rectangular  #=> [1, 2]
  # ```
  def rect: () -> [ Integer | Float | Rational | BigDecimal, Integer | Float | Rational | BigDecimal ]

  # Returns an array; \[cmp.real, cmp.imag\].
  #
  # ```ruby
  # Complex(1, 2).rectangular  #=> [1, 2]
  # ```
  def rectangular: () -> [ Integer | Float | Rational | BigDecimal, Integer | Float | Rational | BigDecimal ]

  # Returns self.
  #
  # ```ruby
  # Complex(2).to_c      #=> (2+0i)
  # Complex(-8, 6).to_c  #=> (-8+6i)
  # ```
  def to_c: () -> Complex

  # Returns the value as a float if possible (the imaginary part should be
  # exactly zero).
  #
  # ```ruby
  # Complex(1, 0).to_f    #=> 1.0
  # Complex(1, 0.0).to_f  # RangeError
  # Complex(1, 2).to_f    # RangeError
  # ```
  def to_f: () -> Float

  # Returns the value as an integer if possible (the imaginary part should
  # be exactly zero).
  #
  # ```ruby
  # Complex(1, 0).to_i    #=> 1
  # Complex(1, 0.0).to_i  # RangeError
  # Complex(1, 2).to_i    # RangeError
  # ```
  def to_i: () -> Integer

  # Invokes the child class's `to_i` method to convert `num` to an integer.
  #
  #     1.0.class          #=> Float
  #     1.0.to_int.class   #=> Integer
  #     1.0.to_i.class     #=> Integer
  #
  def to_int: () -> Integer

  # Returns the value as a rational if possible (the imaginary part should
  # be exactly zero).
  #
  # ```ruby
  # Complex(1, 0).to_r    #=> (1/1)
  # Complex(1, 0.0).to_r  # RangeError
  # Complex(1, 2).to_r    # RangeError
  # ```
  #
  # See rationalize.
  def to_r: () -> Rational

  # Returns the value as a string.
  #
  # ```ruby
  # Complex(2).to_s                       #=> "2+0i"
  # Complex('-8/6').to_s                  #=> "-4/3+0i"
  # Complex('1/2i').to_s                  #=> "0+1/2i"
  # Complex(0, Float::INFINITY).to_s      #=> "0+Infinity*i"
  # Complex(Float::NAN, Float::NAN).to_s  #=> "NaN+NaN*i"
  # ```
  def to_s: () -> String

  def zero?: () -> bool
end

Complex::I: Complex
