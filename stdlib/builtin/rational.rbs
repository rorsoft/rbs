# A rational number can be represented as a pair of integer numbers: a/b
# (b\>0), where a is the numerator and b is the denominator.
# [Integer](https://ruby-doc.org/core-2.6.3/Integer.html) a equals
# rational a/1 mathematically.
# 
# In Ruby, you can create rational objects with the Kernel\#Rational,
# [\#to\_r](Rational#method-i-to_r), or rationalize
# methods or by suffixing `r` to a literal. The return values will be
# irreducible fractions.
# 
#     Rational(1)      #=> (1/1)
#     Rational(2, 3)   #=> (2/3)
#     Rational(4, -6)  #=> (-2/3)
#     3.to_r           #=> (3/1)
#     2/3r             #=> (2/3)
# 
# You can also create rational objects from floating-point numbers or
# strings.
# 
# ```ruby
# Rational(0.3)    #=> (5404319552844595/18014398509481984)
# Rational('0.3')  #=> (3/10)
# Rational('2/3')  #=> (2/3)
# 
# 0.3.to_r         #=> (5404319552844595/18014398509481984)
# '0.3'.to_r       #=> (3/10)
# '2/3'.to_r       #=> (2/3)
# 0.3.rationalize  #=> (3/10)
# ```
# 
# A rational object is an exact number, which helps you to write programs
# without any rounding errors.
# 
# ```ruby
# 10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
# 10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)
# ```
# 
# However, when an expression includes an inexact component (numerical
# value or operation), it will produce an inexact result.
# 
# ```ruby
# Rational(10) / 3   #=> (10/3)
# Rational(10) / 3.0 #=> 3.3333333333333335
# 
# Rational(-8) ** Rational(1, 3)
#                    #=> (1.0000000000000002+1.7320508075688772i)
# ```
class Rational < Numeric
  public

  def %: (Integer arg0) -> Rational
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal

  def *: (Integer arg0) -> Rational
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def **: (Integer arg0) -> Numeric
        | (Float arg0) -> Numeric
        | (Rational arg0) -> Numeric
        | (BigDecimal arg0) -> BigDecimal
        | (Complex arg0) -> Complex

  def +: (Integer arg0) -> Rational
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def +@: () -> Rational

  def -: (Integer arg0) -> Rational
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def -@: () -> Rational

  def /: (Integer arg0) -> Rational
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def <=>: (Integer arg0) -> Integer
         | (Float arg0) -> Integer
         | (Rational arg0) -> Integer
         | (BigDecimal arg0) -> Integer

  def ==: (Object arg0) -> bool

  # Returns the absolute value of `rat` .
  #
  #     (1/2r).abs    #=> (1/2)
  #     (-1/2r).abs   #=> (1/2)
  #
  # [\#magnitude](Rational.downloaded.ruby_doc#method-i-magnitude) is an
  # alias for [\#abs](Rational.downloaded.ruby_doc#method-i-abs).
  def abs: () -> Rational

  def abs2: () -> Rational

  def angle: () -> Numeric

  def arg: () -> Numeric

  # Returns the smallest number greater than or equal to `rat` with a
  # precision of `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an
  # integer.
  #
  # ```ruby
  # Rational(3).ceil      #=> 3
  # Rational(2, 3).ceil   #=> 1
  # Rational(-3, 2).ceil  #=> -1
  #
  #   #    decimal      -  1  2  3 . 4  5  6
  #   #                   ^  ^  ^  ^   ^  ^
  #   #   precision      -3 -2 -1  0  +1 +2
  #
  # Rational('-123.456').ceil(+1).to_f  #=> -123.4
  # Rational('-123.456').ceil(-1)       #=> -120
  # ```
  def ceil: () -> Integer
          | (?Integer digits) -> Numeric

  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. `clone` copies the frozen (unless :freeze
  # keyword argument is given with a false value) and tainted state of *obj*. See
  # also the discussion under `Object#dup`.
  #
  #     class Klass
  #        attr_accessor :str
  #     end
  #     s1 = Klass.new      #=> #<Klass:0x401b3a38>
  #     s1.str = "Hello"    #=> "Hello"
  #     s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
  #     s2.str[1,4] = "i"   #=> "i"
  #     s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
  #     s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  def clone: (?freeze: bool) -> self

  def coerce: (Integer arg0) -> [ Rational, Rational ]
            | (Float arg0) -> [ Float, Float ]
            | (Rational arg0) -> [ Rational, Rational ]
            | (Complex arg0) -> [ Numeric, Numeric ]

  def conj: () -> Rational

  def conjugate: () -> Rational

  # Returns the denominator (always positive).
  #
  # ```ruby
  # Rational(7).denominator             #=> 1
  # Rational(7, 1).denominator          #=> 1
  # Rational(9, -4).denominator         #=> 4
  # Rational(-2, -10).denominator       #=> 5
  # ```
  def denominator: () -> Integer

  def div: (Integer arg0) -> Integer
         | (Float arg0) -> Integer
         | (Rational arg0) -> Integer
         | (BigDecimal arg0) -> Integer

  def divmod: (Integer | Float | Rational | BigDecimal arg0) -> [ Integer | Float | Rational | BigDecimal, Integer | Float | Rational | BigDecimal ]

  # Produces a shallow copy of *obj*---the instance variables of *obj* are copied,
  # but not the objects they reference. `dup` copies the tainted state of *obj*.
  #
  # This method may have class-specific behavior.  If so, that behavior will be
  # documented under the #`initialize_copy` method of the class.
  #
  # ### on dup vs clone
  #
  # In general, `clone` and `dup` may have different semantics in descendant
  # classes. While `clone` is used to duplicate an object, including its internal
  # state, `dup` typically uses the class of the descendant object to create the
  # new instance.
  #
  # When using #dup, any modules that the object has been extended with will not
  # be copied.
  #
  #     class Klass
  #       attr_accessor :str
  #     end
  #
  #     module Foo
  #       def foo; 'foo'; end
  #     end
  #
  #     s1 = Klass.new #=> #<Klass:0x401b3a38>
  #     s1.extend(Foo) #=> #<Klass:0x401b3a38>
  #     s1.foo #=> "foo"
  #
  #     s2 = s1.clone #=> #<Klass:0x401b3a38>
  #     s2.foo #=> "foo"
  #
  #     s3 = s1.dup #=> #<Klass:0x401b3a38>
  #     s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401b3a38>
  #
  def dup: () -> self

  # Returns `true` if `num` and `numeric` are the same type and have equal values.
  #  Contrast this with Numeric#==, which performs type conversions.
  #
  #     1 == 1.0        #=> true
  #     1.eql?(1.0)     #=> false
  #     1.0.eql?(1.0)   #=> true
  #
  def eql?: (untyped arg0) -> bool

  def fdiv: (Integer arg0) -> Float
          | (Float arg0) -> Float
          | (Rational arg0) -> Float
          | (BigDecimal arg0) -> Float
          | (Complex arg0) -> Float

  # Returns `true` if `num` is a finite number, otherwise returns `false`.
  #
  def finite?: () -> bool

  # Returns the largest number less than or equal to `rat` with a precision
  # of `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an
  # integer.
  #
  # ```ruby
  # Rational(3).floor      #=> 3
  # Rational(2, 3).floor   #=> 0
  # Rational(-3, 2).floor  #=> -2
  #
  #   #    decimal      -  1  2  3 . 4  5  6
  #   #                   ^  ^  ^  ^   ^  ^
  #   #   precision      -3 -2 -1  0  +1 +2
  #
  # Rational('-123.456').floor(+1).to_f  #=> -123.5
  # Rational('-123.456').floor(-1)       #=> -130
  # ```
  def floor: () -> Integer
           | (?Integer digits) -> Numeric

  def hash: () -> Integer

  # Returns the corresponding imaginary number. Not available for complex numbers.
  #
  #     -42.i  #=> (0-42i)
  #     2.0.i  #=> (0+2.0i)
  #
  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  # Returns `nil`, -1, or 1 depending on whether the value is finite, `-Infinity`,
  # or `+Infinity`.
  #
  def infinite?: () -> Integer?

  # Returns the value as a string for inspection.
  #
  # ```ruby
  # Rational(2).inspect      #=> "(2/1)"
  # Rational(-8, 6).inspect  #=> "(-4/3)"
  # Rational('1/2').inspect  #=> "(1/2)"
  # ```
  def inspect: () -> String

  # Returns `true` if `num` is an Integer.
  #
  #     1.0.integer?   #=> false
  #     1.integer?     #=> true
  #
  def integer?: () -> bool

  # Returns the absolute value of `num`.
  #
  #     12.abs         #=> 12
  #     (-34.56).abs   #=> 34.56
  #     -34.56.abs     #=> 34.56
  #
  # Numeric#magnitude is an alias for Numeric#abs.
  #
  def magnitude: () -> Numeric

  def modulo: (Integer arg0) -> Rational
            | (Float arg0) -> Float
            | (Rational arg0) -> Rational
            | (BigDecimal arg0) -> BigDecimal

  # Returns `true` if `num` is less than 0.
  #
  def negative?: () -> bool

  # Returns `self` if `num` is not zero, `nil` otherwise.
  #
  # This behavior is useful when chaining comparisons:
  #
  #     a = %w( z Bb bB bb BB a aA Aa AA A )
  #     b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
  #     b   #=> ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
  #
  def nonzero?: () -> self?

  # Returns the numerator.
  #
  # ```ruby
  # Rational(7).numerator        #=> 7
  # Rational(7, 1).numerator     #=> 7
  # Rational(9, -4).numerator    #=> -9
  # Rational(-2, -10).numerator  #=> 1
  # ```
  def numerator: () -> Integer

  def phase: () -> Numeric

  # Returns an array; [num.abs, num.arg].
  #
  def polar: () -> [ Numeric, Numeric ]

  # Returns `true` if `num` is greater than 0.
  #
  def positive?: () -> bool

  def quo: (Integer arg0) -> Rational
         | (Float arg0) -> Float
         | (Rational arg0) -> Rational
         | (BigDecimal arg0) -> BigDecimal
         | (Complex arg0) -> Complex

  # Returns a simpler approximation of the value if the optional argument
  # `eps` is given (rat-|eps| \<= result \<= rat+|eps|), self otherwise.
  #
  # ```ruby
  # r = Rational(5033165, 16777216)
  # r.rationalize                    #=> (5033165/16777216)
  # r.rationalize(Rational('0.01'))  #=> (3/10)
  # r.rationalize(Rational('0.1'))   #=> (1/3)
  # ```
  def rationalize: () -> Rational
                 | (?Numeric arg0) -> Rational

  def real: () -> Rational

  def real?: () -> TrueClass

  # Returns an array; [num, 0].
  #
  def rect: () -> [ Numeric, Numeric ]

  # Returns an array; [num, 0].
  #
  def rectangular: () -> [ Numeric, Numeric ]

  # `x.remainder(y)` means `x-y*(x/y).truncate`.
  #
  # See Numeric#divmod.
  #
  def remainder: (Numeric arg0) -> Numeric

  # Returns `rat` rounded to the nearest value with a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an
  # integer.
  #
  # ```ruby
  # Rational(3).round      #=> 3
  # Rational(2, 3).round   #=> 1
  # Rational(-3, 2).round  #=> -2
  #
  #   #    decimal      -  1  2  3 . 4  5  6
  #   #                   ^  ^  ^  ^   ^  ^
  #   #   precision      -3 -2 -1  0  +1 +2
  #
  # Rational('-123.456').round(+1).to_f  #=> -123.5
  # Rational('-123.456').round(-1)       #=> -120
  # ```
  #
  # The optional `half` keyword argument is available similar to
  # [Float\#round](https://ruby-doc.org/core-2.6.3/Float.html#method-i-round)
  # .
  #
  # ```ruby
  # Rational(25, 100).round(1, half: :up)    #=> (3/10)
  # Rational(25, 100).round(1, half: :down)  #=> (1/5)
  # Rational(25, 100).round(1, half: :even)  #=> (1/5)
  # Rational(35, 100).round(1, half: :up)    #=> (2/5)
  # Rational(35, 100).round(1, half: :down)  #=> (3/10)
  # Rational(35, 100).round(1, half: :even)  #=> (2/5)
  # Rational(-25, 100).round(1, half: :up)   #=> (-3/10)
  # Rational(-25, 100).round(1, half: :down) #=> (-1/5)
  # Rational(-25, 100).round(1, half: :even) #=> (-1/5)
  # ```
  def round: () -> Integer
           | (?Integer arg0) -> Numeric

  # Invokes the given block with the sequence of numbers starting at `num`,
  # incremented by `step` (defaulted to `1`) on each call.
  #
  # The loop finishes when the value to be passed to the block is greater than
  # `limit` (if `step` is positive) or less than `limit` (if `step` is negative),
  # where `limit` is defaulted to infinity.
  #
  # In the recommended keyword argument style, either or both of `step` and
  # `limit` (default infinity) can be omitted.  In the fixed position argument
  # style, zero as a step (i.e. `num.step(limit, 0)`) is not allowed for
  # historical compatibility reasons.
  #
  # If all the arguments are integers, the loop operates using an integer counter.
  #
  # If any of the arguments are floating point numbers, all are converted to
  # floats, and the loop is executed *floor(n + n*Float::EPSILON) + 1* times,
  # where *n = (limit - num)/step*.
  #
  # Otherwise, the loop starts at `num`, uses either the less-than (`<`) or
  # greater-than (`>`) operator to compare the counter against `limit`, and
  # increments itself using the `+` operator.
  #
  # If no block is given, an Enumerator is returned instead. Especially, the
  # enumerator is an Enumerator::ArithmeticSequence if both `limit` and `step` are
  # kind of Numeric or `nil`.
  #
  # For example:
  #
  #     p 1.step.take(4)
  #     p 10.step(by: -1).take(4)
  #     3.step(to: 5) {|i| print i, " " }
  #     1.step(10, 2) {|i| print i, " " }
  #     Math::E.step(to: Math::PI, by: 0.2) {|f| print f, " " }
  #
  # Will produce:
  #
  #     [1, 2, 3, 4]
  #     [10, 9, 8, 7]
  #     3 4 5
  #     1 3 5 7 9
  #     2.718281828459045 2.9182818284590453 3.118281828459045
  #
  # # arglists
  #     num.step(by: step, to: limit) {|i| block }   ->  self
  #     num.step(by: step, to: limit)                ->  an_enumerator
  #     num.step(by: step, to: limit)                ->  an_arithmetic_sequence
  #     num.step(limit=nil, step=1) {|i| block }     ->  self
  #     num.step(limit=nil, step=1)                  ->  an_enumerator
  #     num.step(limit=nil, step=1)                  ->  an_arithmetic_sequence
  #
  def step: (?Numeric? limit, ?Numeric step) { (Numeric arg0) -> void } -> self
          | (?by: Numeric, ?to: Numeric) { (Numeric arg0) -> void } -> self
          | (?Numeric? limit, ?Numeric step) -> ::Enumerator[Numeric, self]
          | (?by: Numeric, ?to: Numeric) -> ::Enumerator[Numeric, self]

  def to_c: () -> Complex

  # Returns the value as a
  # [Float](https://ruby-doc.org/core-2.6.3/Float.html).
  #
  # ```ruby
  # Rational(2).to_f      #=> 2.0
  # Rational(9, 4).to_f   #=> 2.25
  # Rational(-3, 4).to_f  #=> -0.75
  # Rational(20, 3).to_f  #=> 6.666666666666667
  # ```
  def to_f: () -> Float

  # Returns the truncated value as an integer.
  #
  # Equivalent to
  # [\#truncate](Rational.downloaded.ruby_doc#method-i-truncate).
  #
  # ```ruby
  # Rational(2, 3).to_i    #=> 0
  # Rational(3).to_i       #=> 3
  # Rational(300.6).to_i   #=> 300
  # Rational(98, 71).to_i  #=> 1
  # Rational(-31, 2).to_i  #=> -15
  # ```
  def to_i: () -> Integer

  # Invokes the child class's `to_i` method to convert `num` to an integer.
  #
  #     1.0.class          #=> Float
  #     1.0.to_int.class   #=> Integer
  #     1.0.to_i.class     #=> Integer
  #
  def to_int: () -> Integer

  # Returns self.
  #
  # ```ruby
  # Rational(2).to_r      #=> (2/1)
  # Rational(-8, 6).to_r  #=> (-4/3)
  # ```
  def to_r: () -> Rational

  # Returns the value as a string.
  #
  # ```ruby
  # Rational(2).to_s      #=> "2/1"
  # Rational(-8, 6).to_s  #=> "-4/3"
  # Rational('1/2').to_s  #=> "1/2"
  # ```
  def to_s: () -> String

  # Returns `rat` truncated (toward zero) to a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns a rational when `ndigits` is positive, otherwise returns an
  # integer.
  #
  # ```ruby
  # Rational(3).truncate      #=> 3
  # Rational(2, 3).truncate   #=> 0
  # Rational(-3, 2).truncate  #=> -1
  #
  #   #    decimal      -  1  2  3 . 4  5  6
  #   #                   ^  ^  ^  ^   ^  ^
  #   #   precision      -3 -2 -1  0  +1 +2
  #
  # Rational('-123.456').truncate(+1).to_f  #=> -123.4
  # Rational('-123.456').truncate(-1)       #=> -120
  # ```
  def truncate: () -> Integer
              | (?Integer arg0) -> Rational

  def zero?: () -> bool
end
