# Holds [Integer](Integer) values. You cannot add a
# singleton method to an [Integer](Integer) object,
# any attempt to do so will raise a
# [TypeError](https://ruby-doc.org/core-2.6.3/TypeError.html).
class Integer < Numeric
  def self.sqrt: (Numeric n) -> Integer

  public

  def %: (Integer arg0) -> Integer
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal

  def &: (Integer arg0) -> Integer

  def *: (Integer arg0) -> Integer
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def **: (Integer arg0) -> Numeric
        | (Float arg0) -> Numeric
        | (Rational arg0) -> Numeric
        | (BigDecimal arg0) -> BigDecimal
        | (Complex arg0) -> Complex

  def +: (Integer arg0) -> Integer
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def +@: () -> Integer

  def -: (Integer arg0) -> Integer
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def -@: () -> Integer

  def /: (Integer arg0) -> Integer
       | (Float arg0) -> Float
       | (Rational arg0) -> Rational
       | (BigDecimal arg0) -> BigDecimal
       | (Complex arg0) -> Complex

  def <: (Integer arg0) -> bool
       | (Float arg0) -> bool
       | (Rational arg0) -> bool
       | (BigDecimal arg0) -> bool

  def <<: (Integer arg0) -> Integer

  def <=: (Integer arg0) -> bool
        | (Float arg0) -> bool
        | (Rational arg0) -> bool
        | (BigDecimal arg0) -> bool

  def <=>: (Integer arg0) -> Integer
         | (Float arg0) -> Integer
         | (Rational arg0) -> Integer
         | (BigDecimal arg0) -> Integer

  def ==: (Object arg0) -> bool

  def ===: (Object arg0) -> bool

  def >: (Integer arg0) -> bool
       | (Float arg0) -> bool
       | (Rational arg0) -> bool
       | (BigDecimal arg0) -> bool

  def >=: (Integer arg0) -> bool
        | (Float arg0) -> bool
        | (Rational arg0) -> bool
        | (BigDecimal arg0) -> bool

  def >>: (Integer arg0) -> Integer

  def []: (Integer arg0) -> Integer
        | (Rational arg0) -> Integer
        | (Float arg0) -> Integer
        | (BigDecimal arg0) -> Integer

  def ^: (Integer arg0) -> Integer

  # Returns the absolute value of `int` .
  #
  # ```ruby
  # (-12345).abs   #=> 12345
  # -12345.abs     #=> 12345
  # 12345.abs      #=> 12345
  # ```
  #
  # [\#magnitude](Integer.downloaded.ruby_doc#method-i-magnitude) is an
  # alias for [\#abs](Integer.downloaded.ruby_doc#method-i-abs).
  def abs: () -> Integer

  def abs2: () -> Integer

  def allbits?: (_ToInt mask) -> bool

  def angle: () -> Numeric

  def anybits?: (_ToInt mask) -> bool

  def arg: () -> Numeric

  # Returns the number of bits of the value of `int` .
  #
  # "Number of bits" means the bit position of the highest bit which is
  # different from the sign bit (where the least significant bit has bit
  # position 1). If there is no such bit (zero or minus one), zero is
  # returned.
  #
  # I.e. this method returns *ceil(log2(int \< 0 ? -int : int+1))* .
  #
  # ```ruby
  # (-2**1000-1).bit_length   #=> 1001
  # (-2**1000).bit_length     #=> 1000
  # (-2**1000+1).bit_length   #=> 1000
  # (-2**12-1).bit_length     #=> 13
  # (-2**12).bit_length       #=> 12
  # (-2**12+1).bit_length     #=> 12
  # -0x101.bit_length         #=> 9
  # -0x100.bit_length         #=> 8
  # -0xff.bit_length          #=> 8
  # -2.bit_length             #=> 1
  # -1.bit_length             #=> 0
  # 0.bit_length              #=> 0
  # 1.bit_length              #=> 1
  # 0xff.bit_length           #=> 8
  # 0x100.bit_length          #=> 9
  # (2**12-1).bit_length      #=> 12
  # (2**12).bit_length        #=> 13
  # (2**12+1).bit_length      #=> 13
  # (2**1000-1).bit_length    #=> 1000
  # (2**1000).bit_length      #=> 1001
  # (2**1000+1).bit_length    #=> 1001
  # ```
  #
  # This method can be used to detect overflow in
  # [Array\#pack](https://ruby-doc.org/core-2.6.3/Array.html#method-i-pack)
  # as follows:
  #
  # ```ruby
  # if n.bit_length < 32
  #   [n].pack("l") # no overflow
  # else
  #   raise "overflow"
  # end
  # ```
  def bit_length: () -> Integer

  # Returns the smallest number greater than or equal to `int` with a
  # precision of `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  # ```ruby
  # 1.ceil           #=> 1
  # 1.ceil(2)        #=> 1
  # 18.ceil(-1)      #=> 20
  # (-18).ceil(-1)   #=> -10
  # ```
  def ceil: () -> Integer
          | (?Integer digits) -> Numeric

  # Returns a string containing the character represented by the `int` 's
  # value according to `encoding` .
  #
  # ```ruby
  # 65.chr    #=> "A"
  # 230.chr   #=> "\xE6"
  # 255.chr(Encoding::UTF_8)   #=> "\u00FF"
  # ```
  def chr: () -> String
         | (?Encoding | String arg0) -> String

  def clone: (?freeze: bool) -> self

  def coerce: (Numeric arg0) -> [ Integer | Float | Rational | BigDecimal, Integer | Float | Rational | BigDecimal ]

  def conj: () -> Integer

  def conjugate: () -> Integer

  # Returns 1.
  def denominator: () -> Integer

  def digits: (?Integer base) -> ::Array[Integer]

  def div: (Integer arg0) -> Integer
         | (Float arg0) -> Integer
         | (Rational arg0) -> Integer
         | (BigDecimal arg0) -> Integer

  def divmod: (Integer | Float | Rational | BigDecimal arg0) -> [ Integer | Float | Rational | BigDecimal, Integer | Float | Rational | BigDecimal ]

  def downto: (Integer limit) { (Integer arg0) -> untyped } -> Integer
            | (Integer limit) -> ::Enumerator[Integer, self]

  def dup: () -> self

  def eql?: (Object arg0) -> bool

  # Returns `true` if `int` is an even number.
  def even?: () -> bool

  def fdiv: (Integer arg0) -> Float
          | (Float arg0) -> Float
          | (Rational arg0) -> Float
          | (BigDecimal arg0) -> BigDecimal
          | (Complex arg0) -> Complex

  # Returns `true` if `num` is a finite number, otherwise returns `false`.
  #
  def finite?: () -> bool

  # Returns the largest number less than or equal to `int` with a precision
  # of `ndigits` decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  # ```ruby
  # 1.floor           #=> 1
  # 1.floor(2)        #=> 1
  # 18.floor(-1)      #=> 10
  # (-18).floor(-1)   #=> -20
  # ```
  def floor: () -> Integer
           | (?Integer digits) -> Numeric

  def gcd: (Integer arg0) -> Integer

  def gcdlcm: (Integer arg0) -> [ Integer, Integer ]

  # Returns the corresponding imaginary number. Not available for complex numbers.
  #
  #     -42.i  #=> (0-42i)
  #     2.0.i  #=> (0+2.0i)
  #
  def i: () -> Complex

  def imag: () -> Integer

  def imaginary: () -> Integer

  # Returns `nil`, -1, or 1 depending on whether the value is finite, `-Infinity`,
  # or `+Infinity`.
  #
  def infinite?: () -> Integer?

  alias inspect to_s

  # Since `int` is already an [Integer](Integer.downloaded.ruby_doc), this
  # always returns `true` .
  def integer?: () -> TrueClass

  def lcm: (Integer arg0) -> Integer

  # Returns the absolute value of `int` .
  #
  # ```ruby
  # (-12345).abs   #=> 12345
  # -12345.abs     #=> 12345
  # 12345.abs      #=> 12345
  # ```
  #
  # [\#magnitude](Integer.downloaded.ruby_doc#method-i-magnitude) is an
  # alias for [\#abs](Integer.downloaded.ruby_doc#method-i-abs).
  def magnitude: () -> Integer

  def modulo: (Integer arg0) -> Integer
            | (Float arg0) -> Float
            | (Rational arg0) -> Rational
            | (BigDecimal arg0) -> BigDecimal

  # Returns `true` if `num` is less than 0.
  #
  def negative?: () -> bool

  # Returns the successor of `int`, i.e. the
  # [Integer](Integer.downloaded.ruby_doc) equal to `int+1` .
  #
  # ```ruby
  # 1.next      #=> 2
  # (-1).next   #=> 0
  # 1.succ      #=> 2
  # (-1).succ   #=> 0
  # ```
  def next: () -> Integer

  def nobits?: (_ToInt mask) -> bool

  # Returns `self` if `num` is not zero, `nil` otherwise.
  #
  # This behavior is useful when chaining comparisons:
  #
  #     a = %w( z Bb bB bb BB a aA Aa AA A )
  #     b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
  #     b   #=> ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
  #
  def nonzero?: () -> self?

  # Returns self.
  def numerator: () -> Integer

  # Returns `true` if `int` is an odd number.
  def odd?: () -> bool

  # Returns the `int` itself.
  #
  # ```ruby
  # 97.ord   #=> 97
  # ```
  #
  # This method is intended for compatibility to character literals in Ruby
  # 1.9.
  #
  # For example, `?a.ord` returns 97 both in 1.8 and 1.9.
  def ord: () -> Integer

  def phase: () -> Numeric

  # Returns an array; [num.abs, num.arg].
  #
  def polar: () -> [ Numeric, Numeric ]

  # Returns `true` if `num` is greater than 0.
  #
  def positive?: () -> bool

  def pow: (Numeric numeric) -> Numeric
         | (Integer other, Integer modulo) -> Integer

  # Returns the predecessor of `int`, i.e. the
  # [Integer](Integer.downloaded.ruby_doc) equal to `int-1` .
  #
  # ```ruby
  # 1.pred      #=> 0
  # (-1).pred   #=> -2
  # ```
  def pred: () -> Integer

  def quo: (Integer arg0) -> Rational
         | (Float arg0) -> Float
         | (Rational arg0) -> Rational
         | (BigDecimal arg0) -> BigDecimal
         | (Complex arg0) -> Complex

  # Returns the value as a rational. The optional argument `eps` is always
  # ignored.
  def rationalize: () -> Rational
                 | (?Numeric arg0) -> Rational

  def real: () -> Integer

  def real?: () -> TrueClass

  # Returns an array; [num, 0].
  #
  def rect: () -> [ Numeric, Numeric ]

  # Returns an array; [num, 0].
  #
  def rectangular: () -> [ Numeric, Numeric ]

  def remainder: (Integer arg0) -> Integer
               | (Float arg0) -> Float
               | (Rational arg0) -> Rational
               | (BigDecimal arg0) -> BigDecimal

  # Returns `int` rounded to the nearest value with a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  # ```ruby
  # 1.round           #=> 1
  # 1.round(2)        #=> 1
  # 15.round(-1)      #=> 20
  # (-15).round(-1)   #=> -20
  # ```
  #
  # The optional `half` keyword argument is available similar to
  # [Float\#round](https://ruby-doc.org/core-2.6.3/Float.html#method-i-round)
  # .
  #
  # ```ruby
  # 25.round(-1, half: :up)      #=> 30
  # 25.round(-1, half: :down)    #=> 20
  # 25.round(-1, half: :even)    #=> 20
  # 35.round(-1, half: :up)      #=> 40
  # 35.round(-1, half: :down)    #=> 30
  # 35.round(-1, half: :even)    #=> 40
  # (-25).round(-1, half: :up)   #=> -30
  # (-25).round(-1, half: :down) #=> -20
  # (-25).round(-1, half: :even) #=> -20
  # ```
  def round: () -> Integer
           | (?Numeric arg0) -> Numeric

  # Invoked as a callback whenever a singleton method is added to the receiver.
  #
  #     module Chatty
  #       def Chatty.singleton_method_added(id)
  #         puts "Adding #{id.id2name}"
  #       end
  #       def self.one()     end
  #       def two()          end
  #       def Chatty.three() end
  #     end
  #
  # *produces:*
  #
  #     Adding singleton_method_added
  #     Adding one
  #     Adding three
  #
  def singleton_method_added: (Symbol) -> void

  # Returns the number of bytes in the machine representation of `int`
  # (machine dependent).
  #
  # ```ruby
  # 1.size               #=> 8
  # -1.size              #=> 8
  # 2147483647.size      #=> 8
  # (256**10 - 1).size   #=> 10
  # (256**20 - 1).size   #=> 20
  # (256**40 - 1).size   #=> 40
  # ```
  def size: () -> Integer

  # Invokes the given block with the sequence of numbers starting at `num`,
  # incremented by `step` (defaulted to `1`) on each call.
  #
  # The loop finishes when the value to be passed to the block is greater than
  # `limit` (if `step` is positive) or less than `limit` (if `step` is negative),
  # where `limit` is defaulted to infinity.
  #
  # In the recommended keyword argument style, either or both of `step` and
  # `limit` (default infinity) can be omitted.  In the fixed position argument
  # style, zero as a step (i.e. `num.step(limit, 0)`) is not allowed for
  # historical compatibility reasons.
  #
  # If all the arguments are integers, the loop operates using an integer counter.
  #
  # If any of the arguments are floating point numbers, all are converted to
  # floats, and the loop is executed *floor(n + n*Float::EPSILON) + 1* times,
  # where *n = (limit - num)/step*.
  #
  # Otherwise, the loop starts at `num`, uses either the less-than (`<`) or
  # greater-than (`>`) operator to compare the counter against `limit`, and
  # increments itself using the `+` operator.
  #
  # If no block is given, an Enumerator is returned instead. Especially, the
  # enumerator is an Enumerator::ArithmeticSequence if both `limit` and `step` are
  # kind of Numeric or `nil`.
  #
  # For example:
  #
  #     p 1.step.take(4)
  #     p 10.step(by: -1).take(4)
  #     3.step(to: 5) {|i| print i, " " }
  #     1.step(10, 2) {|i| print i, " " }
  #     Math::E.step(to: Math::PI, by: 0.2) {|f| print f, " " }
  #
  # Will produce:
  #
  #     [1, 2, 3, 4]
  #     [10, 9, 8, 7]
  #     3 4 5
  #     1 3 5 7 9
  #     2.718281828459045 2.9182818284590453 3.118281828459045
  #
  # # arglists
  #     num.step(by: step, to: limit) {|i| block }   ->  self
  #     num.step(by: step, to: limit)                ->  an_enumerator
  #     num.step(by: step, to: limit)                ->  an_arithmetic_sequence
  #     num.step(limit=nil, step=1) {|i| block }     ->  self
  #     num.step(limit=nil, step=1)                  ->  an_enumerator
  #     num.step(limit=nil, step=1)                  ->  an_arithmetic_sequence
  #
  def step: (?Numeric? limit, ?Numeric step) { (Numeric arg0) -> void } -> self
          | (?by: Numeric, ?to: Numeric) { (Numeric arg0) -> void } -> self
          | (?Numeric? limit, ?Numeric step) -> ::Enumerator[Numeric, self]
          | (?by: Numeric, ?to: Numeric) -> ::Enumerator[Numeric, self]

  # Returns the successor of `int`, i.e. the
  # [Integer](Integer.downloaded.ruby_doc) equal to `int+1` .
  #
  # ```ruby
  # 1.next      #=> 2
  # (-1).next   #=> 0
  # 1.succ      #=> 2
  # (-1).succ   #=> 0
  # ```
  def succ: () -> Integer

  def times: () { (Integer arg0) -> untyped } -> Integer
           | () -> ::Enumerator[Integer, self]

  def to_c: () -> Complex

  # Converts `int` to a [Float](https://ruby-doc.org/core-2.6.3/Float.html)
  # . If `int` doesn't fit in a
  # [Float](https://ruby-doc.org/core-2.6.3/Float.html), the result is
  # infinity.
  def to_f: () -> Float

  # Since `int` is already an [Integer](Integer.downloaded.ruby_doc),
  # returns `self` .
  #
  # [to\_int](Integer.downloaded.ruby_doc#method-i-to_int) is an alias for
  # [to\_i](Integer.downloaded.ruby_doc#method-i-to_i).
  def to_i: () -> Integer

  # Since `int` is already an [Integer](Integer.downloaded.ruby_doc),
  # returns `self` .
  #
  # [to\_int](Integer.downloaded.ruby_doc#method-i-to_int) is an alias for
  # [to\_i](Integer.downloaded.ruby_doc#method-i-to_i).
  def to_int: () -> Integer

  # Returns the value as a rational.
  #
  # ```ruby
  # 1.to_r        #=> (1/1)
  # (1<<64).to_r  #=> (18446744073709551616/1)
  # ```
  def to_r: () -> Rational

  # Returns a string containing the place-value representation of `int` with
  # radix `base` (between 2 and 36).
  #
  # ```ruby
  # 12345.to_s       #=> "12345"
  # 12345.to_s(2)    #=> "11000000111001"
  # 12345.to_s(8)    #=> "30071"
  # 12345.to_s(10)   #=> "12345"
  # 12345.to_s(16)   #=> "3039"
  # 12345.to_s(36)   #=> "9ix"
  # 78546939656932.to_s(36)  #=> "rubyrules"
  # ```
  #
  #
  #
  # Also aliased as: [inspect](Integer.downloaded.ruby_doc#method-i-inspect)
  def to_s: () -> String
          | (2) -> String
          | (3) -> String
          | (4) -> String
          | (5) -> String
          | (6) -> String
          | (7) -> String
          | (8) -> String
          | (9) -> String
          | (10) -> String
          | (11) -> String
          | (12) -> String
          | (13) -> String
          | (14) -> String
          | (15) -> String
          | (16) -> String
          | (17) -> String
          | (18) -> String
          | (19) -> String
          | (20) -> String
          | (21) -> String
          | (22) -> String
          | (23) -> String
          | (24) -> String
          | (25) -> String
          | (26) -> String
          | (27) -> String
          | (28) -> String
          | (29) -> String
          | (30) -> String
          | (31) -> String
          | (32) -> String
          | (33) -> String
          | (34) -> String
          | (35) -> String
          | (36) -> String

  # Returns `int` truncated (toward zero) to a precision of `ndigits`
  # decimal digits (default: 0).
  #
  # When the precision is negative, the returned value is an integer with at
  # least `ndigits.abs` trailing zeros.
  #
  # Returns `self` when `ndigits` is zero or positive.
  #
  # ```ruby
  # 1.truncate           #=> 1
  # 1.truncate(2)        #=> 1
  # 18.truncate(-1)      #=> 10
  # (-18).truncate(-1)   #=> -10
  # ```
  def truncate: () -> Integer

  def upto: (Integer arg0) { (Integer arg0) -> untyped } -> Integer
          | (Integer arg0) -> ::Enumerator[Integer, self]

  def zero?: () -> bool

  def |: (Integer arg0) -> Integer

  def ~: () -> Integer
end

