class Hash
  include JSON::Ext::Generator::GeneratorMethods::Hash

  include Enumerable

  def self.[]: [U, V] (*::Array[[ U, V ]] arg0) -> ::Hash[U, V]

  def self.try_convert: (untyped) -> untyped

  public

  def <: (::Hash[K, V]) -> bool

  def <=: (::Hash[K, V]) -> bool

  # Equality --- At the `Object` level, `==` returns `true` only if `obj` and
  # `other` are the same object. Typically, this method is overridden in
  # descendant classes to provide class-specific meaning.
  # 
  # Unlike `==`, the `equal?` method should never be overridden by subclasses as
  # it is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  # 
  #     obj = "a"
  #     other = obj.dup
  # 
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  # 
  # The `eql?` method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For objects of class
  # `Object`, `eql?` is synonymous with `==`.  Subclasses normally continue this
  # tradition by aliasing `eql?` to their overridden `==` method, but there are
  # exceptions.  `Numeric` types, for example, perform type conversion across
  # `==`, but not across `eql?`, so:
  # 
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  # 
  def ==: (untyped other) -> bool

  def >: (::Hash[K, V]) -> bool

  def >=: (::Hash[K, V]) -> bool

  def []: (K arg0) -> V?

  def []=: (K arg0, V arg1) -> V

  # Passes each element of the collection to the given block. The method
  # returns `true` if the block ever returns a value other than `false` or
  # `nil` . If the block is not given, Ruby adds an implicit block of `{
  # |obj| obj }` that will cause
  # [any?](Enumerable.downloaded.ruby_doc#method-i-any-3F) to return `true`
  # if at least one of the collection members is not `false` or `nil` .
  # 
  # If instead a pattern is supplied, the method returns whether `pattern
  # === element` for any collection member.
  # 
  # ```ruby
  # %w[ant bear cat].any? { |word| word.length >= 3 } #=> true
  # %w[ant bear cat].any? { |word| word.length >= 4 } #=> true
  # %w[ant bear cat].any?(/d/)                        #=> false
  # [nil, true, 99].any?(Integer)                     #=> true
  # [nil, true, 99].any?                              #=> true
  # [].any?                                           #=> false
  # ```
  def any?: () -> bool
          | () { (Elem arg0) -> untyped } -> bool

  def assoc: (K arg0) -> ::Array[K | V]

  # Removes all key-value pairs from *hsh* .
  # 
  # ```ruby
  # h = { "a" => 100, "b" => 200 }   #=> {"a"=>100, "b"=>200}
  # h.clear                          #=> {}
  # ```
  def clear: () -> ::Hash[K, V]

  def compact: () -> ::Hash[K, V]

  def compact!: () -> ::Hash[K, V]?

  # Makes *hsh* compare its keys by their identity, i.e. it will consider
  # exact same objects as same keys.
  # 
  # ```ruby
  # h1 = { "a" => 100, "b" => 200, :c => "c" }
  # h1["a"]        #=> 100
  # h1.compare_by_identity
  # h1.compare_by_identity? #=> true
  # h1["a".dup]    #=> nil  # different objects.
  # h1[:c]         #=> "c"  # same symbols are all same.
  # ```
  def compare_by_identity: () -> ::Hash[K, V]

  # Returns `true` if *hsh* will compare its keys by their identity. Also
  # see `Hash#compare_by_identity` .
  def compare_by_identity?: () -> bool

  def deconstruct_keys: (untyped) -> untyped

  def default: (?K arg0) -> V?
             | (?K arg0) { (K arg0) -> V } -> V?

  def default=: (V arg0) -> V

  def default_proc: () -> untyped

  def default_proc=: (untyped) -> untyped

  def delete: (K arg0) -> V?
            | [U] (K arg0) { (K arg0) -> U } -> (U | V)

  def delete_if: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]
               | () -> ::Enumerator[[ K, V ], self]

  def dig: (*untyped) -> untyped

  def each: () { ([ K, V ] arg0) -> untyped } -> ::Hash[K, V]
          | () -> ::Enumerator[[ K, V ], self]

  def each_key: () { (K arg0) -> untyped } -> ::Hash[K, V]
              | () -> ::Enumerator[[ K, V ], self]

  def each_pair: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]
               | () -> ::Enumerator[[ K, V ], self]

  def each_value: () { (V arg0) -> untyped } -> ::Hash[K, V]
                | () -> ::Enumerator[[ K, V ], self]

  # Returns `true` if *hsh* contains no key-value pairs.
  # 
  # ```ruby
  # {}.empty?   #=> true
  # ```
  def empty?: () -> bool

  # Equality --- At the `Object` level, `==` returns `true` only if `obj` and
  # `other` are the same object. Typically, this method is overridden in
  # descendant classes to provide class-specific meaning.
  # 
  # Unlike `==`, the `equal?` method should never be overridden by subclasses as
  # it is used to determine object identity (that is, `a.equal?(b)` if and only if
  # `a` is the same object as `b`):
  # 
  #     obj = "a"
  #     other = obj.dup
  # 
  #     obj == other      #=> true
  #     obj.equal? other  #=> false
  #     obj.equal? obj    #=> true
  # 
  # The `eql?` method returns `true` if `obj` and `other` refer to the same hash
  # key.  This is used by Hash to test members for equality.  For objects of class
  # `Object`, `eql?` is synonymous with `==`.  Subclasses normally continue this
  # tradition by aliasing `eql?` to their overridden `==` method, but there are
  # exceptions.  `Numeric` types, for example, perform type conversion across
  # `==`, but not across `eql?`, so:
  # 
  #     1 == 1.0     #=> true
  #     1.eql? 1.0   #=> false
  # 
  def eql?: (untyped) -> bool

  def fetch: (K arg0) -> V
           | [X] (K arg0, ?X arg1) -> (V | X)
           | [X] (K arg0) { (K arg0) -> X } -> (V | X)

  def fetch_values: (*untyped) -> untyped

  def filter: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]
            | () -> ::Enumerator[[ K, V ], self]

  def filter!: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]?
             | () -> ::Enumerator[[ K, V ], self]

  def flatten: (?Integer level) -> ::Array[untyped]

  def has_key?: (K arg0) -> bool

  def has_value?: (V arg0) -> bool

  def hash: () -> Integer

  def include?: (untyped arg0) -> bool

  def index: (untyped) -> untyped

  # Return the contents of this hash as a string.
  # 
  # ```ruby
  # h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300  }
  # h.to_s   #=> "{\"c\"=>300, \"a\"=>100, \"d\"=>400}"
  # ```
  # 
  # 
  # 
  # Also aliased as: [to\_s](Hash.downloaded.ruby_doc#method-i-to_s)
  def inspect: () -> String

  # Returns a new hash created by using *hsh* â€™s values as keys, and the
  # keys as values. If a key with the same value already exists in the *hsh*
  # , then the last one defined will be used, the earlier value(s) will be
  # discarded.
  # 
  # ```ruby
  # h = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 }
  # h.invert   #=> {0=>"a", 100=>"m", 200=>"d", 300=>"y"}
  # ```
  # 
  # If there is no key with the same value,
  # [\#invert](Hash.downloaded.ruby_doc#method-i-invert) is involutive.
  # 
  # ```ruby
  # h = { a: 1, b: 3, c: 4 }
  # h.invert.invert == h #=> true
  # ```
  # 
  # The condition, no key with the same value, can be tested by comparing
  # the size of inverted hash.
  # 
  # ```ruby
  # # no key with the same value
  # h = { a: 1, b: 3, c: 4 }
  # h.size == h.invert.size #=> true
  # 
  # # two (or more) keys has the same value
  # h = { a: 1, b: 3, c: 1 }
  # h.size == h.invert.size #=> false
  # ```
  def invert: () -> ::Hash[V, K]

  def keep_if: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]
             | () -> ::Enumerator[[ K, V ], self]

  def key: (V arg0) -> K?

  def key?: (K arg0) -> bool

  # Returns a new array populated with the keys from this hash. See also
  # `Hash#values` .
  # 
  # ```ruby
  # h = { "a" => 100, "b" => 200, "c" => 300, "d" => 400 }
  # h.keys   #=> ["a", "b", "c", "d"]
  # ```
  def keys: () -> ::Array[K]

  # Returns the number of key-value pairs in the hash.
  # 
  # ```ruby
  # h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }
  # h.size          #=> 4
  # h.delete("a")   #=> 200
  # h.size          #=> 3
  # h.length        #=> 3
  # ```
  # 
  # [\#length](Hash.downloaded.ruby_doc#method-i-length) is an alias for
  # [\#size](Hash.downloaded.ruby_doc#method-i-size).
  def length: () -> Integer

  def member?: (K arg0) -> bool

  def merge: [A, B] (*::Hash[A, B] arg0) -> ::Hash[A | K, B | V]
           | [A, B] (*::Hash[A, B] arg0) { (K arg0, V arg1, B arg2) -> (V | B) } -> ::Hash[A | K, B | V]

  def merge!: (*untyped) -> untyped

  def pretty_print: (untyped q) -> untyped

  def pretty_print_cycle: (untyped q) -> untyped

  def rassoc: (K arg0) -> ::Array[K | V]

  # Rebuilds the hash based on the current hash values for each key. If
  # values of key objects have changed since they were inserted, this method
  # will reindex *hsh* . If `Hash#rehash` is called while an iterator is
  # traversing the hash, a `RuntimeError` will be raised in the iterator.
  # 
  # ```ruby
  # a = [ "a", "b" ]
  # c = [ "c", "d" ]
  # h = { a => 100, c => 300 }
  # h[a]       #=> 100
  # a[0] = "z"
  # h[a]       #=> nil
  # h.rehash   #=> {["z", "b"]=>100, ["c", "d"]=>300}
  # h[a]       #=> 100
  # ```
  def rehash: () -> ::Hash[K, V]

  # Returns a new hash consisting of entries for which the block returns
  # false.
  # 
  # If no block is given, an enumerator is returned instead.
  # 
  # ```ruby
  # h = { "a" => 100, "b" => 200, "c" => 300 }
  # h.reject {|k,v| k < "b"}  #=> {"b" => 200, "c" => 300}
  # h.reject {|k,v| v > 100}  #=> {"a" => 100}
  # ```
  def reject: () -> ::Enumerator[[ K, V ], self]
            | () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]

  def reject!: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]

  def replace: (::Hash[K, V]) -> ::Hash[K, V]

  def select: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]
            | () -> ::Enumerator[[ K, V ], self]

  def select!: () { (K arg0, V arg1) -> untyped } -> ::Hash[K, V]?
             | () -> ::Enumerator[[ K, V ], self]

  # Removes a key-value pair from *hsh* and returns it as the two-item array
  # `[` *key, value* `]`, or the hashâ€™s default value if the hash is empty.
  # 
  # ```ruby
  # h = { 1 => "a", 2 => "b", 3 => "c" }
  # h.shift   #=> [1, "a"]
  # h         #=> {2=>"b", 3=>"c"}
  # ```
  def shift: () -> ::Array[K | V]

  # Returns the number of key-value pairs in the hash.
  # 
  # ```ruby
  # h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }
  # h.size          #=> 4
  # h.delete("a")   #=> 200
  # h.size          #=> 3
  # h.length        #=> 3
  # ```
  # 
  # [\#length](Hash.downloaded.ruby_doc#method-i-length) is an alias for
  # [\#size](Hash.downloaded.ruby_doc#method-i-size).
  def size: () -> Integer

  def slice: (*untyped) -> untyped

  def store: (K arg0, V arg1) -> V

  # Converts *hsh* to a nested array of `[` *key, value* `]` arrays.
  # 
  # ```ruby
  # h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300  }
  # h.to_a   #=> [["c", 300], ["a", 100], ["d", 400]]
  # ```
  def to_a: () -> ::Array[[ K, V ]]

  # Implemented in C++
  # Returns the result of interpreting *enum* as a list of `[key, value]`
  # pairs.
  # 
  #     %i[hello world].each_with_index.to_h
  #       # => {:hello => 0, :world => 1}
  # 
  # If a block is given, the results of the block on each element of the
  # enum will be used as pairs.
  # 
  # ```ruby
  # (1..5).to_h {|x| [x, x ** 2]}
  #   #=> {1=>1, 2=>4, 3=>9, 4=>16, 5=>25}
  # ```
  def to_h: () -> ::Hash[untyped, untyped]

  # Returns `self`.
  def to_hash: () -> ::Hash[K, V]

  def to_proc: () -> ^(K) -> V

  alias to_s inspect

  def transform_keys: (*untyped) -> untyped

  def transform_keys!: (*untyped) -> untyped

  def transform_values: () -> untyped

  def transform_values!: () -> untyped

  def update: (*untyped) -> untyped

  def value?: (V arg0) -> bool

  # Returns a new array populated with the values from *hsh* . See also
  # `Hash#keys` .
  # 
  # ```ruby
  # h = { "a" => 100, "b" => 200, "c" => 300 }
  # h.values   #=> [100, 200, 300]
  # ```
  def values: () -> ::Array[V]

  def values_at: (*K arg0) -> ::Array[V]

  private

  incompatible def initialize: () -> void
                             | (?untyped default) -> void
                             | () { (Hash[untyped, untyped] hash, untyped key) -> untyped } -> void

  def initialize_copy: (self object) -> self
end
